"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xorByte = exports.subContractId = exports.contractIdFromTx = exports.addressFromTokenId = exports.addressFromContractId = exports.addressFromScript = exports.addressFromPublicKey = exports.publicKeyFromPrivateKey = exports.groupOfPrivateKey = exports.tokenIdFromAddress = exports.contractIdFromAddress = exports.groupOfAddress = exports.validateAddress = exports.AddressType = void 0;
const elliptic_1 = require("elliptic");
const bn_js_1 = __importDefault(require("bn.js"));
const constants_1 = require("../constants");
const blakejs_1 = __importDefault(require("blakejs"));
const bs58_1 = __importDefault(require("./bs58"));
const djb2_1 = __importDefault(require("./djb2"));
const utils_1 = require("./utils");
const ec = new elliptic_1.ec('secp256k1');
var AddressType;
(function (AddressType) {
    AddressType[AddressType["P2PKH"] = 0] = "P2PKH";
    AddressType[AddressType["P2MPKH"] = 1] = "P2MPKH";
    AddressType[AddressType["P2SH"] = 2] = "P2SH";
    AddressType[AddressType["P2C"] = 3] = "P2C";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
function validateAddress(address) {
    let decoded;
    try {
        decoded = bs58_1.default.decode(address);
    }
    catch (_) {
        throw new Error('Invalid base58 string');
    }
    if (decoded.length === 0)
        throw new Error('Address is empty');
    const addressType = decoded[0];
    if (addressType === AddressType.P2MPKH) {
        // [1, n, ...hashes, m]
        if ((decoded.length - 3) % 32 === 0)
            return;
    }
    else if (addressType === AddressType.P2PKH || addressType === AddressType.P2SH || addressType === AddressType.P2C) {
        // [type, ...hash]
        if (decoded.length === 33)
            return;
    }
    throw new Error(`Invalid address: ${address}`);
}
exports.validateAddress = validateAddress;
function groupOfAddress(address) {
    validateAddress(address);
    const decoded = bs58_1.default.decode(address);
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2PKH) {
        return groupOfP2pkhAddress(addressBody);
    }
    else if (addressType == AddressType.P2MPKH) {
        return groupOfP2mpkhAddress(addressBody);
    }
    else if (addressType == AddressType.P2SH) {
        return groupOfP2shAddress(addressBody);
    }
    else {
        // Contract Address
        const id = contractIdFromAddress(address);
        return id[`${id.length - 1}`];
    }
}
exports.groupOfAddress = groupOfAddress;
function groupOfAddressBytes(bytes) {
    const hint = (0, djb2_1.default)(bytes) | 1;
    const hash = xorByte(hint);
    const group = hash % constants_1.TOTAL_NUMBER_OF_GROUPS;
    return group;
}
// Pay to public key hash address
function groupOfP2pkhAddress(address) {
    return groupOfAddressBytes(address);
}
// Pay to multiple public key hash address
function groupOfP2mpkhAddress(address) {
    return groupOfAddressBytes(address.slice(1, 33));
}
// Pay to script hash address
function groupOfP2shAddress(address) {
    return groupOfAddressBytes(address);
}
function contractIdFromAddress(address) {
    return idFromAddress(address);
}
exports.contractIdFromAddress = contractIdFromAddress;
function tokenIdFromAddress(address) {
    return idFromAddress(address);
}
exports.tokenIdFromAddress = tokenIdFromAddress;
function idFromAddress(address) {
    const decoded = bs58_1.default.decode(address);
    if (decoded.length == 0)
        throw new Error('Address string is empty');
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2C) {
        return addressBody;
    }
    else {
        throw new Error(`Invalid contract address type: ${addressType}`);
    }
}
function groupOfPrivateKey(privateKey, keyType) {
    return groupOfAddress(addressFromPublicKey(publicKeyFromPrivateKey(privateKey, keyType), keyType));
}
exports.groupOfPrivateKey = groupOfPrivateKey;
function publicKeyFromPrivateKey(privateKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const key = ec.keyFromPrivate(privateKey);
        return key.getPublic(true, 'hex');
    }
    else {
        return ec.g.mul(new bn_js_1.default(privateKey, 16)).encode('hex', true).slice(2);
    }
}
exports.publicKeyFromPrivateKey = publicKeyFromPrivateKey;
function addressFromPublicKey(publicKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const addressType = Buffer.from([AddressType.P2PKH]);
        const hash = Buffer.from(blakejs_1.default.blake2b(Buffer.from(publicKey, 'hex'), undefined, 32));
        const bytes = Buffer.concat([addressType, hash]);
        return bs58_1.default.encode(bytes);
    }
    else {
        const lockupScript = Buffer.from(`0101000000000458144020${publicKey}8685`, 'hex');
        return addressFromScript(lockupScript);
    }
}
exports.addressFromPublicKey = addressFromPublicKey;
function addressFromScript(script) {
    const scriptHash = blakejs_1.default.blake2b(script, undefined, 32);
    const addressType = Buffer.from([AddressType.P2SH]);
    return bs58_1.default.encode(Buffer.concat([addressType, scriptHash]));
}
exports.addressFromScript = addressFromScript;
function addressFromContractId(contractId) {
    const addressType = Buffer.from([AddressType.P2C]);
    const hash = Buffer.from((0, utils_1.hexToBinUnsafe)(contractId));
    const bytes = Buffer.concat([addressType, hash]);
    return bs58_1.default.encode(bytes);
}
exports.addressFromContractId = addressFromContractId;
function addressFromTokenId(tokenId) {
    const contractId = tokenId; // contract ID is the same as token ID
    return addressFromContractId(contractId);
}
exports.addressFromTokenId = addressFromTokenId;
function contractIdFromTx(txId, outputIndex) {
    const txIdBin = (0, utils_1.hexToBinUnsafe)(txId);
    const data = Buffer.concat([txIdBin, Buffer.from([outputIndex])]);
    const hash = blakejs_1.default.blake2b(data, undefined, 32);
    return (0, utils_1.binToHex)(hash);
}
exports.contractIdFromTx = contractIdFromTx;
function subContractId(parentContractId, pathInHex, group) {
    if (group < 0 || group >= constants_1.TOTAL_NUMBER_OF_GROUPS) {
        throw new Error(`Invalid group ${group}`);
    }
    const data = Buffer.concat([(0, utils_1.hexToBinUnsafe)(parentContractId), (0, utils_1.hexToBinUnsafe)(pathInHex)]);
    const bytes = Buffer.concat([
        blakejs_1.default.blake2b(blakejs_1.default.blake2b(data, undefined, 32), undefined, 32).slice(0, -1),
        Buffer.from([group])
    ]);
    return (0, utils_1.binToHex)(bytes);
}
exports.subContractId = subContractId;
function xorByte(intValue) {
    const byte0 = (intValue >> 24) & 0xff;
    const byte1 = (intValue >> 16) & 0xff;
    const byte2 = (intValue >> 8) & 0xff;
    const byte3 = intValue & 0xff;
    return (byte0 ^ byte1 ^ byte2 ^ byte3) & 0xff;
}
exports.xorByte = xorByte;
