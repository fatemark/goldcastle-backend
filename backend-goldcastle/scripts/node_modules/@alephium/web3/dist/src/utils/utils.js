"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = exports.isDevnet = exports.sleep = exports.hexToString = exports.stringToHex = exports.blockChainIndex = exports.binToHex = exports.hexToBinUnsafe = exports.toNonNegativeBigInt = exports.isHexString = exports.signatureDecode = exports.encodeHexSignature = exports.encodeSignature = exports.networkIds = void 0;
const elliptic_1 = require("elliptic");
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer/");
const constants_1 = require("../constants");
exports.networkIds = ['mainnet', 'testnet', 'devnet'];
const ec = new elliptic_1.ec('secp256k1');
function encodeSignature(signature) {
    let sNormalized = signature.s;
    if (ec.n && signature.s.cmp(ec.nh) === 1) {
        sNormalized = ec.n.sub(signature.s);
    }
    const r = signature.r.toString('hex', 66).slice(2);
    const s = sNormalized.toString('hex', 66).slice(2);
    return r + s;
}
exports.encodeSignature = encodeSignature;
function encodeHexSignature(rHex, sHex) {
    return encodeSignature({ r: new bn_js_1.default(rHex, 'hex'), s: new bn_js_1.default(sHex, 'hex') });
}
exports.encodeHexSignature = encodeHexSignature;
// the signature should be in hex string format for 64 bytes
function signatureDecode(ec, signature) {
    if (signature.length !== 128) {
        throw new Error('Invalid signature length');
    }
    const sHex = signature.slice(64, 128);
    const s = new bn_js_1.default(sHex, 'hex');
    if (ec.n && s.cmp(ec.nh) < 1) {
        const decoded = { r: signature.slice(0, 64), s: sHex };
        return decoded;
    }
    else {
        throw new Error('The signature is not normalized');
    }
}
exports.signatureDecode = signatureDecode;
function isHexString(input) {
    return input.length % 2 === 0 && /^[0-9a-fA-F]*$/.test(input);
}
exports.isHexString = isHexString;
function toNonNegativeBigInt(input) {
    try {
        const bigIntValue = BigInt(input);
        return bigIntValue < 0n ? undefined : bigIntValue;
    }
    catch {
        return undefined;
    }
}
exports.toNonNegativeBigInt = toNonNegativeBigInt;
function hexToBinUnsafe(hex) {
    return buffer_1.Buffer.from(hex, 'hex');
}
exports.hexToBinUnsafe = hexToBinUnsafe;
function binToHex(bin) {
    return buffer_1.Buffer.from(bin).toString('hex');
}
exports.binToHex = binToHex;
function blockChainIndex(blockHash) {
    if (blockHash.length != 64) {
        throw Error(`Invalid block hash: ${blockHash}`);
    }
    const rawIndex = Number('0x' + blockHash.slice(-4)) % constants_1.TOTAL_NUMBER_OF_CHAINS;
    return { fromGroup: Math.floor(rawIndex / constants_1.TOTAL_NUMBER_OF_GROUPS), toGroup: rawIndex % constants_1.TOTAL_NUMBER_OF_GROUPS };
}
exports.blockChainIndex = blockChainIndex;
function stringToHex(str) {
    let hex = '';
    for (let i = 0; i < str.length; i++) {
        hex += '' + str.charCodeAt(i).toString(16);
    }
    return hex;
}
exports.stringToHex = stringToHex;
function hexToString(str) {
    if (!isHexString(str)) {
        throw new Error(`Invalid hex string: ${str}`);
    }
    return buffer_1.Buffer.from(str, 'hex').toString();
}
exports.hexToString = hexToString;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function isDevnet(networkId) {
    return networkId !== 0 && networkId !== 1;
}
exports.isDevnet = isDevnet;
// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
function assertType() { }
exports.assertType = assertType;
