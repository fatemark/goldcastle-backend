import { NamedVals, node, NodeProvider, Number256, Token } from '../api';
import { SignDeployContractTxParams, SignDeployContractTxResult, SignExecuteScriptTxParams, SignerProvider, Address } from '../signer';
import { Optional } from '../utils';
import { EventSubscribeOptions, EventSubscription } from './events';
export type FieldsSig = node.FieldsSig;
export type EventSig = node.EventSig;
export type FunctionSig = node.FunctionSig;
export type Fields = NamedVals;
export type Arguments = NamedVals;
export type HexString = string;
export type Constant = node.Constant;
export type Enum = node.Enum;
export declare const StdIdFieldName = "__stdInterfaceId";
declare enum SourceKind {
    Contract = 0,
    Script = 1,
    AbstractContract = 2,
    Interface = 3
}
export type CompilerOptions = node.CompilerOptions & {
    errorOnWarnings: boolean;
};
export declare const DEFAULT_NODE_COMPILER_OPTIONS: node.CompilerOptions;
export declare const DEFAULT_COMPILER_OPTIONS: CompilerOptions;
declare class TypedMatcher<T extends SourceKind> {
    matcher: RegExp;
    type: T;
    constructor(pattern: string, type: T);
}
declare class SourceInfo {
    type: SourceKind;
    name: string;
    contractRelativePath: string;
    sourceCode: string;
    sourceCodeHash: string;
    isExternal: boolean;
    getArtifactPath(artifactsRootDir: string): string;
    constructor(type: SourceKind, name: string, sourceCode: string, sourceCodeHash: string, contractRelativePath: string, isExternal: boolean);
    static from(type: SourceKind, name: string, sourceCode: string, contractRelativePath: string, isExternal: boolean): Promise<SourceInfo>;
}
declare class Compiled<T extends Artifact> {
    sourceInfo: SourceInfo;
    artifact: T;
    warnings: string[];
    constructor(sourceInfo: SourceInfo, artifact: T, warnings: string[]);
}
type CodeInfo = {
    sourceFile: string;
    sourceCodeHash: string;
    bytecodeDebugPatch: string;
    codeHashDebug: string;
    warnings: string[];
};
export declare class ProjectArtifact {
    static readonly artifactFileName = ".project.json";
    fullNodeVersion: string;
    compilerOptionsUsed: node.CompilerOptions;
    infos: Map<string, CodeInfo>;
    static checkCompilerOptionsParameter(compilerOptions: node.CompilerOptions): void;
    constructor(fullNodeVersion: string, compilerOptionsUsed: node.CompilerOptions, infos: Map<string, CodeInfo>);
    static isCodeChanged(current: ProjectArtifact, previous: ProjectArtifact): boolean;
    saveToFile(rootPath: string): Promise<void>;
    needToReCompile(compilerOptions: node.CompilerOptions, sourceInfos: SourceInfo[], fullNodeVersion: string): boolean;
    static from(rootPath: string): Promise<ProjectArtifact | undefined>;
}
export declare class Project {
    sourceInfos: SourceInfo[];
    contracts: Map<string, Compiled<Contract>>;
    scripts: Map<string, Compiled<Script>>;
    projectArtifact: ProjectArtifact;
    readonly contractsRootDir: string;
    readonly artifactsRootDir: string;
    static currentProject: Project;
    static readonly importRegex: RegExp;
    static readonly abstractContractMatcher: TypedMatcher<SourceKind>;
    static readonly contractMatcher: TypedMatcher<SourceKind.Contract>;
    static readonly interfaceMatcher: TypedMatcher<SourceKind.Interface>;
    static readonly scriptMatcher: TypedMatcher<SourceKind.Script>;
    static readonly matchers: TypedMatcher<SourceKind>[];
    static buildProjectArtifact(fullNodeVersion: string, sourceInfos: SourceInfo[], contracts: Map<string, Compiled<Contract>>, scripts: Map<string, Compiled<Script>>, compilerOptions: node.CompilerOptions): ProjectArtifact;
    private constructor();
    static checkCompilerWarnings(warnings: string[], errorOnWarnings: boolean): void;
    static contract(name: string): Contract;
    static script(name: string): Script;
    private saveArtifactsToFile;
    contractByCodeHash(codeHash: string): Contract;
    private static getCompileResult;
    private static compile;
    private static loadArtifacts;
    private static getImportSourcePath;
    private static handleImports;
    private static loadSourceFile;
    private static loadSourceFiles;
    static readonly DEFAULT_CONTRACTS_DIR = "contracts";
    static readonly DEFAULT_ARTIFACTS_DIR = "artifacts";
    static build(compilerOptionsPartial?: Partial<CompilerOptions>, projectRootDir?: string, contractsRootDir?: string, artifactsRootDir?: string, defaultFullNodeVersion?: string | undefined): Promise<void>;
}
export declare abstract class Artifact {
    readonly version: string;
    readonly name: string;
    readonly functions: FunctionSig[];
    constructor(version: string, name: string, functions: FunctionSig[]);
    abstract buildByteCodeToDeploy(initialFields: Fields, isDevnet: boolean): string;
    publicFunctions(): string[];
    usingPreapprovedAssetsFunctions(): string[];
    usingAssetsInContractFunctions(): string[];
    isDevnet(signer: SignerProvider): Promise<boolean>;
}
export declare class Contract extends Artifact {
    readonly bytecode: string;
    readonly bytecodeDebugPatch: string;
    readonly codeHash: string;
    readonly fieldsSig: FieldsSig;
    readonly eventsSig: EventSig[];
    readonly constants: Constant[];
    readonly enums: Enum[];
    readonly stdInterfaceId?: HexString;
    readonly bytecodeDebug: string;
    readonly codeHashDebug: string;
    constructor(version: string, name: string, bytecode: string, bytecodeDebugPatch: string, codeHash: string, codeHashDebug: string, fieldsSig: FieldsSig, eventsSig: EventSig[], functions: FunctionSig[], constants: Constant[], enums: Enum[], stdInterfaceId?: HexString);
    static fromJson(artifact: any, bytecodeDebugPatch?: string, codeHashDebug?: string): Contract;
    static fromCompileResult(result: node.CompileContractResult): Contract;
    static fromArtifactFile(path: string, bytecodeDebugPatch: string, codeHashDebug: string): Promise<Contract>;
    toString(): string;
    getInitialFieldsWithDefaultValues(): Fields;
    toState<T extends Fields>(fields: T, asset: Asset, address?: string): ContractState<T>;
    static randomAddress(): string;
    printDebugMessages(funcName: string, messages: DebugMessage[]): void;
    toApiFields(fields?: Fields): node.Val[];
    toApiArgs(funcName: string, args?: Arguments): node.Val[];
    getMethodIndex(funcName: string): number;
    toApiContractStates(states?: ContractState[]): node.ContractState[] | undefined;
    toApiTestContractParams(funcName: string, params: TestContractParams): node.TestContract;
    fromApiContractState(state: node.ContractState): ContractState<Fields>;
    static fromApiContractState(state: node.ContractState, getContractByCodeHash?: (codeHash: string) => Contract): ContractState;
    static ContractCreatedEventIndex: number;
    static ContractCreatedEvent: EventSig;
    static ContractDestroyedEventIndex: number;
    static ContractDestroyedEvent: EventSig;
    static fromApiEvent(event: node.ContractEventByTxId, codeHash: string | undefined, txId: string, getContractByCodeHash?: (codeHash: string) => Contract): ContractEvent;
    fromApiTestContractResult(methodName: string, result: node.TestContractResult, txId: string): TestContractResult<unknown>;
    txParamsForDeployment<P extends Fields>(signer: SignerProvider, params: DeployContractParams<P>): Promise<SignDeployContractTxParams>;
    buildByteCodeToDeploy(initialFields: Fields, isDevnet: boolean): string;
    static fromApiEvents(events: node.ContractEventByTxId[], addressToCodeHash: Map<string, string>, txId: string, getContractByCodeHash?: (codeHash: string) => Contract): ContractEvent[];
    toApiCallContract<T extends Arguments>(params: CallContractParams<T>, groupIndex: number, contractAddress: string, methodIndex: number): node.CallContract;
    fromApiCallContractResult(result: node.CallContractResult, txId: string, methodIndex: number, getContractByCodeHash?: (codeHash: string) => Contract): CallContractResult<unknown>;
}
export declare class Script extends Artifact {
    readonly bytecodeTemplate: string;
    readonly bytecodeDebugPatch: string;
    readonly fieldsSig: FieldsSig;
    constructor(version: string, name: string, bytecodeTemplate: string, bytecodeDebugPatch: string, fieldsSig: FieldsSig, functions: FunctionSig[]);
    static fromCompileResult(result: node.CompileScriptResult): Script;
    static fromJson(artifact: any, bytecodeDebugPatch?: string): Script;
    static fromArtifactFile(path: string, bytecodeDebugPatch: string): Promise<Script>;
    toString(): string;
    txParamsForExecution<P extends Fields>(signer: SignerProvider, params: ExecuteScriptParams<P>): Promise<SignExecuteScriptTxParams>;
    buildByteCodeToDeploy(initialFields: Fields): string;
}
export interface Asset {
    alphAmount: Number256;
    tokens?: Token[];
}
export interface InputAsset {
    address: string;
    asset: Asset;
}
export interface ContractState<T extends Fields = Fields> {
    address: string;
    contractId: string;
    bytecode: string;
    initialStateHash?: string;
    codeHash: string;
    fields: T;
    fieldsSig: FieldsSig;
    asset: Asset;
}
export declare function toApiVals(fields: Fields, names: string[], types: string[]): node.Val[];
export interface TestContractParams<F extends Fields = Fields, A extends Arguments = Arguments> {
    group?: number;
    address?: string;
    callerAddress?: string;
    blockHash?: string;
    blockTimeStamp?: number;
    txId?: string;
    initialFields: F;
    initialAsset?: Asset;
    testArgs: A;
    existingContracts?: ContractState[];
    inputAssets?: InputAsset[];
}
export interface ContractEvent<T extends Fields = Fields> {
    txId: string;
    blockHash: string;
    contractAddress: string;
    eventIndex: number;
    name: string;
    fields: T;
}
export type DebugMessage = node.DebugMessage;
export interface TestContractResult<R> {
    contractId: string;
    contractAddress: string;
    returns: R;
    gasUsed: number;
    contracts: ContractState[];
    txOutputs: Output[];
    events: ContractEvent[];
    debugMessages: DebugMessage[];
}
export declare type Output = AssetOutput | ContractOutput;
export interface AssetOutput extends Asset {
    type: string;
    address: string;
    lockTime: number;
    message: string;
}
export interface ContractOutput {
    type: string;
    address: string;
    alphAmount: Number256;
    tokens?: Token[];
}
export declare function randomTxId(): string;
export interface DeployContractParams<P extends Fields = Fields> {
    initialFields: P;
    initialAttoAlphAmount?: Number256;
    initialTokenAmounts?: Token[];
    issueTokenAmount?: Number256;
    issueTokenTo?: string;
    gasAmount?: number;
    gasPrice?: Number256;
}
export type DeployContractResult<T extends ContractInstance> = Omit<SignDeployContractTxResult, 'contractId' | 'contractAddress' | 'groupIndex'> & {
    contractInstance: T;
};
export declare abstract class ContractFactory<I extends ContractInstance, F extends Fields = Fields> {
    readonly contract: Contract;
    constructor(contract: Contract);
    abstract at(address: string): I;
    deploy(signer: SignerProvider, deployParams: DeployContractParams<F>): Promise<DeployContractResult<I>>;
    stateForTest(initFields: F, asset?: Asset, address?: string): ContractState<F>;
}
export declare class ExecutableScript<P extends Fields = Fields> {
    readonly script: Script;
    constructor(script: Script);
    execute(signer: SignerProvider, params: ExecuteScriptParams<P>): Promise<ExecuteScriptResult>;
}
export interface ExecuteScriptParams<P extends Fields = Fields> {
    initialFields: P;
    attoAlphAmount?: Number256;
    tokens?: Token[];
    gasAmount?: number;
    gasPrice?: Number256;
}
export interface ExecuteScriptResult {
    groupIndex: number;
    unsignedTx: string;
    txId: string;
    signature: string;
    gasAmount: number;
    gasPrice: Number256;
}
export interface CallContractParams<T extends Arguments = Arguments> {
    args: T;
    worldStateBlockHash?: string;
    txId?: string;
    existingContracts?: string[];
    inputAssets?: node.TestInputAsset[];
}
export interface CallContractResult<R> {
    returns: R;
    gasUsed: number;
    contracts: ContractState[];
    txInputs: string[];
    txOutputs: Output[];
    events: ContractEvent[];
    debugMessages: DebugMessage[];
}
export declare const CreateContractEventAddress: string;
export declare const DestroyContractEventAddress: string;
export type ContractCreatedEventFields = {
    address: Address;
    parentAddress?: Address;
    stdInterfaceIdGuessed?: HexString;
};
export type ContractDestroyedEventFields = {
    address: Address;
};
export type ContractCreatedEvent = ContractEvent<ContractCreatedEventFields>;
export type ContractDestroyedEvent = ContractEvent<ContractDestroyedEventFields>;
export declare function decodeContractCreatedEvent(event: node.ContractEvent): Omit<ContractCreatedEvent, 'contractAddress'>;
export declare function decodeContractDestroyedEvent(event: node.ContractEvent): Omit<ContractDestroyedEvent, 'contractAddress'>;
export declare function subscribeEventsFromContract<T extends Fields, M extends ContractEvent<T>>(options: EventSubscribeOptions<M>, address: string, eventIndex: number, decodeFunc: (event: node.ContractEvent) => M, fromCount?: number): EventSubscription;
export declare function addStdIdToFields<F extends Fields>(contract: Contract, fields: F): F | (F & {
    __stdInterfaceId: HexString;
});
export declare function testMethod<I extends ContractInstance, F extends Fields, A extends Arguments, R>(contract: ContractFactory<I, F>, methodName: string, params: Optional<TestContractParams<F, A>, 'testArgs' | 'initialFields'>): Promise<TestContractResult<R>>;
export declare abstract class ContractInstance {
    readonly address: Address;
    readonly contractId: string;
    readonly groupIndex: number;
    constructor(address: Address);
}
export declare function fetchContractState<F extends Fields, I extends ContractInstance>(contract: ContractFactory<I, F>, instance: ContractInstance): Promise<ContractState<F>>;
export declare function subscribeContractCreatedEvent(options: EventSubscribeOptions<ContractCreatedEvent>, fromCount?: number): EventSubscription;
export declare function subscribeContractDestroyedEvent(options: EventSubscribeOptions<ContractDestroyedEvent>, fromCount?: number): EventSubscription;
export declare function decodeEvent<F extends Fields, M extends ContractEvent<F>>(contract: Contract, instance: ContractInstance, event: node.ContractEvent, targetEventIndex: number): M;
export declare function subscribeContractEvent<F extends Fields, M extends ContractEvent<F>>(contract: Contract, instance: ContractInstance, options: EventSubscribeOptions<M>, eventName: string, fromCount?: number): EventSubscription;
export declare function subscribeContractEvents(contract: Contract, instance: ContractInstance, options: EventSubscribeOptions<ContractEvent<any>>, fromCount?: number): EventSubscription;
export declare function callMethod<I extends ContractInstance, F extends Fields, A extends Arguments, R>(contract: ContractFactory<I, F>, instance: ContractInstance, methodName: string, params: Optional<CallContractParams<A>, 'args'>, getContractByCodeHash?: (codeHash: string) => Contract): Promise<CallContractResult<R>>;
export declare function multicallMethods<I extends ContractInstance, F extends Fields>(contract: ContractFactory<I, F>, instance: ContractInstance, calls: Record<string, Optional<CallContractParams<any>, 'args'>>, getContractByCodeHash?: (codeHash: string) => Contract): Promise<Record<string, CallContractResult<any>>>;
export declare function getContractEventsCurrentCount(contractAddress: Address): Promise<number>;
export declare const getContractIdFromUnsignedTx: (nodeProvider: NodeProvider, unsignedTx: string) => Promise<HexString>;
export declare const getTokenIdFromUnsignedTx: (nodeProvider: NodeProvider, unsignedTx: string) => Promise<HexString>;
export declare function tryGetCallResult(result: node.CallContractResult): node.CallContractSucceeded;
export {};
