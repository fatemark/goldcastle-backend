"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDebugBytecode = exports.encodeContractField = exports.buildContractByteCode = exports.buildScriptByteCode = exports.falttenFields = exports.encodeScriptField = exports.encodeScriptFieldAsString = exports.encodeAddress = exports.encodeByteVec = exports.encodeU256 = exports.encodeI256 = exports.encodeBool = void 0;
const buffer_1 = require("buffer/");
const api_1 = require("../api");
const utils_1 = require("../utils");
const bigIntZero = BigInt(0);
class UnSigned {
}
UnSigned.oneByteBound = BigInt(0x40);
UnSigned.twoByteBound = UnSigned.oneByteBound << BigInt(8);
UnSigned.fourByteBound = UnSigned.oneByteBound << BigInt(8 * 3);
UnSigned.u256UpperBound = BigInt(1) << BigInt(256);
class Signed {
}
_a = Signed;
Signed.oneByteBound = BigInt(0x20);
Signed.twoByteBound = Signed.oneByteBound << BigInt(8);
Signed.fourByteBound = Signed.oneByteBound << BigInt(8 * 3);
Signed.i256UpperBound = BigInt(1) << BigInt(255);
Signed.i256LowerBound = -_a.i256UpperBound;
class CompactInt {
}
CompactInt.oneBytePrefix = 0x00;
CompactInt.oneByteNegPrefix = 0xc0;
CompactInt.twoBytePrefix = 0x40;
CompactInt.twoByteNegPrefix = 0x80;
CompactInt.fourBytePrefix = 0x80;
CompactInt.fourByteNegPrefix = 0x40;
CompactInt.multiBytePrefix = 0xc0;
function encodeBool(bool) {
    return bool ? Uint8Array.from([1]) : Uint8Array.from([0]);
}
exports.encodeBool = encodeBool;
function encodeI256(i256) {
    if (i256 >= bigIntZero) {
        return encodeI256Positive(i256);
    }
    else {
        return encodeI256Negative(i256);
    }
}
exports.encodeI256 = encodeI256;
// n should be positive
function toByteArray(n, signed, notBit) {
    let hex = n.toString(16);
    if (hex.length % 2 === 1) {
        hex = '0' + hex;
    }
    else if (signed && hex[0] >= '8') {
        hex = '00' + hex; // add the byte for sign
    }
    const byteLength = hex.length / 2;
    const bytes = new Uint8Array(byteLength + 1);
    for (let index = 0; index < byteLength; index++) {
        const offset = index * 2;
        const byte = parseInt(hex.slice(offset, offset + 2), 16);
        bytes[`${index + 1}`] = notBit ? ~byte : byte;
    }
    const header = byteLength - 4 + CompactInt.multiBytePrefix;
    bytes[0] = header;
    return bytes;
}
function encodeI256Positive(i256) {
    if (i256 < Signed.oneByteBound) {
        return new Uint8Array([Number(i256) + CompactInt.oneBytePrefix]);
    }
    else if (i256 < Signed.twoByteBound) {
        const num = Number(i256);
        return new Uint8Array([(num >> 8) + CompactInt.twoBytePrefix, num & 0xff]);
    }
    else if (i256 < Signed.fourByteBound) {
        const num = Number(i256);
        return new Uint8Array([(num >> 24) + CompactInt.fourBytePrefix, (num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff]);
    }
    else if (i256 < Signed.i256UpperBound) {
        return toByteArray(i256, true, false);
    }
    else {
        throw Error(`Too large number for i256: ${i256}`);
    }
}
function encodeI256Negative(i256) {
    if (i256 >= -Signed.oneByteBound) {
        const num = Number(i256);
        return new Uint8Array([(num ^ CompactInt.oneByteNegPrefix) & 0xff]);
    }
    else if (i256 >= -Signed.twoByteBound) {
        const num = Number(i256);
        return new Uint8Array([((num >> 8) ^ CompactInt.twoByteNegPrefix) & 0xff, num & 0xff]);
    }
    else if (i256 >= -Signed.fourByteBound) {
        const num = Number(i256);
        return new Uint8Array([
            ((num >> 24) ^ CompactInt.fourByteNegPrefix) & 0xff,
            (num >> 16) & 0xff,
            (num >> 8) & 0xff,
            num & 0xff
        ]);
    }
    else if (i256 >= Signed.i256LowerBound) {
        return toByteArray(~i256, true, true);
    }
    else {
        throw Error(`Too small number for i256: ${i256}`);
    }
}
function encodeU256(u256) {
    if (u256 < bigIntZero) {
        throw Error(`Negative number for U256: ${u256}`);
    }
    else if (u256 < UnSigned.oneByteBound) {
        return new Uint8Array([Number(u256) + CompactInt.oneBytePrefix]);
    }
    else if (u256 < UnSigned.twoByteBound) {
        const num = Number(u256);
        return new Uint8Array([((num >> 8) & 0xff) + CompactInt.twoBytePrefix, num & 0xff]);
    }
    else if (u256 < UnSigned.fourByteBound) {
        const num = Number(u256);
        return new Uint8Array([
            ((num >> 24) & 0xff) + CompactInt.fourBytePrefix,
            (num >> 16) & 0xff,
            (num >> 8) & 0xff,
            num & 0xff
        ]);
    }
    else if (u256 < UnSigned.u256UpperBound) {
        return toByteArray(u256, false, false);
    }
    else {
        throw Error(`Too large number for U256: ${u256}`);
    }
}
exports.encodeU256 = encodeU256;
function encodeByteVec(bytes) {
    if (!(0, utils_1.isHexString)(bytes)) {
        throw Error(`Given value ${bytes} is not a valid hex string`);
    }
    const buffer0 = buffer_1.Buffer.from(bytes, 'hex');
    const buffer1 = buffer_1.Buffer.from(encodeI256(BigInt(buffer0.length)));
    return buffer_1.Buffer.concat([buffer1, buffer0]);
}
exports.encodeByteVec = encodeByteVec;
function encodeAddress(address) {
    return utils_1.bs58.decode(address);
}
exports.encodeAddress = encodeAddress;
function invalidScriptField(tpe, value) {
    return Error(`Invalid script field ${value} for type ${tpe}`);
}
var Instruction;
(function (Instruction) {
    Instruction[Instruction["trueConst"] = 3] = "trueConst";
    Instruction[Instruction["falseConst"] = 4] = "falseConst";
    Instruction[Instruction["i256Const0"] = 5] = "i256Const0";
    Instruction[Instruction["i256Const1"] = 6] = "i256Const1";
    Instruction[Instruction["i256Const2"] = 7] = "i256Const2";
    Instruction[Instruction["i256Const3"] = 8] = "i256Const3";
    Instruction[Instruction["i256Const4"] = 9] = "i256Const4";
    Instruction[Instruction["i256Const5"] = 10] = "i256Const5";
    Instruction[Instruction["i256ConstN1"] = 11] = "i256ConstN1";
    Instruction[Instruction["u256Const0"] = 12] = "u256Const0";
    Instruction[Instruction["u256Const1"] = 13] = "u256Const1";
    Instruction[Instruction["u256Const2"] = 14] = "u256Const2";
    Instruction[Instruction["u256Const3"] = 15] = "u256Const3";
    Instruction[Instruction["u256Const4"] = 16] = "u256Const4";
    Instruction[Instruction["u256Const5"] = 17] = "u256Const5";
    Instruction[Instruction["i256Const"] = 18] = "i256Const";
    Instruction[Instruction["u256Const"] = 19] = "u256Const";
    Instruction[Instruction["bytesConst"] = 20] = "bytesConst";
    Instruction[Instruction["addressConst"] = 21] = "addressConst";
})(Instruction || (Instruction = {}));
// TODO: optimize
function encodeScriptFieldI256(value) {
    return new Uint8Array([Instruction.i256Const, ...encodeI256(value)]);
}
// TODO: optimize
function encodeScriptFieldU256(value) {
    return new Uint8Array([Instruction.u256Const, ...encodeU256(value)]);
}
function encodeScriptFieldAsString(tpe, value) {
    return buffer_1.Buffer.from(encodeScriptField(tpe, value)).toString('hex');
}
exports.encodeScriptFieldAsString = encodeScriptFieldAsString;
function encodeScriptField(tpe, value) {
    switch (tpe) {
        case 'Bool':
            const byte = (0, api_1.toApiBoolean)(value) ? Instruction.trueConst : Instruction.falseConst;
            return new Uint8Array([byte]);
        case 'I256':
            const i256 = (0, api_1.toApiNumber256)(value);
            return encodeScriptFieldI256(BigInt(i256));
        case 'U256':
            const u256 = (0, api_1.toApiNumber256)(value);
            return encodeScriptFieldU256(BigInt(u256));
        case 'ByteVec':
            const hexStr = (0, api_1.toApiByteVec)(value);
            return new Uint8Array([Instruction.bytesConst, ...encodeByteVec(hexStr)]);
        case 'Address':
            const address = (0, api_1.toApiAddress)(value);
            return new Uint8Array([Instruction.addressConst, ...encodeAddress(address)]);
    }
    throw invalidScriptField(tpe, value);
}
exports.encodeScriptField = encodeScriptField;
function flattenArray(name, type, val, acc) {
    const semiColonIndex = type.lastIndexOf(';');
    if (semiColonIndex == -1) {
        throw new Error(`Invalid array type: ${type}`);
    }
    const subType = type.slice(1, semiColonIndex);
    val.forEach((v, index) => {
        const isArrayType = subType.includes(';');
        const isArrayValue = Array.isArray(v);
        if (isArrayType && isArrayValue) {
            flattenArray(`${name}[${index}]`, subType, v, acc);
        }
        else if (!isArrayType && !isArrayValue) {
            acc.push({ name: `${name}[${index}]`, type: subType, value: v });
        }
        else {
            const value = isArrayValue ? `[` + v.join(', ') + `]` : v.toString();
            throw new Error(`Invalid field, expected type is ${subType}, but value is ${value}`);
        }
    });
}
function falttenFields(fields, fieldsSig) {
    const allFields = [];
    fieldsSig.names.forEach((name, index) => {
        const field = fields[`${name}`];
        if (!(name in fields)) {
            throw new Error(`The value of field ${name} is not provided`);
        }
        const type = fieldsSig.types[`${index}`];
        if (Array.isArray(field)) {
            flattenArray(name, type, field, allFields);
        }
        else {
            allFields.push({ name, type, value: field });
        }
    });
    return allFields;
}
exports.falttenFields = falttenFields;
const scriptFieldRegex = /\{([0-9]*)\}/g;
function buildScriptByteCode(bytecodeTemplate, fields, fieldsSig) {
    const allFields = falttenFields(fields, fieldsSig);
    return bytecodeTemplate.replace(scriptFieldRegex, (_, fieldIndex) => {
        const field = allFields[`${fieldIndex}`];
        return _encodeField(field.name, () => encodeScriptFieldAsString(field.type, field.value));
    });
}
exports.buildScriptByteCode = buildScriptByteCode;
function _encodeField(fieldName, encodeFunc) {
    try {
        return encodeFunc();
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Invalid ${fieldName}, error: ${error.message}`);
        }
        throw error;
    }
}
function encodeFields(fields, fieldsSig, mutable) {
    const fieldIndexes = fieldsSig.isMutable
        .map((_, index) => index)
        .filter((index) => fieldsSig.isMutable[`${index}`] === mutable);
    const fieldsEncoded = fieldIndexes.flatMap((fieldIndex) => {
        const fieldName = fieldsSig.names[`${fieldIndex}`];
        const fieldType = fieldsSig.types[`${fieldIndex}`];
        if (fieldName in fields) {
            const fieldValue = fields[`${fieldName}`];
            return _encodeField(fieldName, () => encodeContractField(fieldType, fieldValue));
        }
        else {
            throw new Error(`The value of field ${fieldName} is not provided`);
        }
    });
    const fieldsLength = buffer_1.Buffer.from(encodeI256(BigInt(fieldsEncoded.length))).toString('hex');
    return fieldsLength + fieldsEncoded.map((f) => buffer_1.Buffer.from(f).toString('hex')).join('');
}
function buildContractByteCode(bytecode, fields, fieldsSig) {
    const encodedImmFields = encodeFields(fields, fieldsSig, false);
    const encodedMutFields = encodeFields(fields, fieldsSig, true);
    return bytecode + encodedImmFields + encodedMutFields;
}
exports.buildContractByteCode = buildContractByteCode;
var ApiValType;
(function (ApiValType) {
    ApiValType[ApiValType["Bool"] = 0] = "Bool";
    ApiValType[ApiValType["I256"] = 1] = "I256";
    ApiValType[ApiValType["U256"] = 2] = "U256";
    ApiValType[ApiValType["ByteVec"] = 3] = "ByteVec";
    ApiValType[ApiValType["Address"] = 4] = "Address";
})(ApiValType || (ApiValType = {}));
function encodeContractFieldI256(value) {
    return new Uint8Array([ApiValType.I256, ...encodeI256(value)]);
}
function encodeContractFieldU256(value) {
    return new Uint8Array([ApiValType.U256, ...encodeU256(value)]);
}
function encodeContractFieldArray(tpe, val) {
    if (!Array.isArray(val)) {
        throw new Error(`Expected array, got ${val}`);
    }
    const semiColonIndex = tpe.lastIndexOf(';');
    if (semiColonIndex == -1) {
        throw new Error(`Invalid Array type: ${tpe}`);
    }
    const subType = tpe.slice(1, semiColonIndex);
    const dim = parseInt(tpe.slice(semiColonIndex + 1, -1));
    if (val.length != dim) {
        throw new Error(`Invalid val dimension: ${val}`);
    }
    else {
        return val.flatMap((v) => encodeContractField(subType, v));
    }
}
function encodeContractField(tpe, value) {
    switch (tpe) {
        case 'Bool':
            const byte = (0, api_1.toApiBoolean)(value) ? 1 : 0;
            return [new Uint8Array([ApiValType.Bool, byte])];
        case 'I256':
            const i256 = (0, api_1.toApiNumber256)(value);
            return [encodeContractFieldI256(BigInt(i256))];
        case 'U256':
            const u256 = (0, api_1.toApiNumber256)(value);
            return [encodeContractFieldU256(BigInt(u256))];
        case 'ByteVec':
            const hexStr = (0, api_1.toApiByteVec)(value);
            return [new Uint8Array([ApiValType.ByteVec, ...encodeByteVec(hexStr)])];
        case 'Address':
            const address = (0, api_1.toApiAddress)(value);
            return [new Uint8Array([ApiValType.Address, ...encodeAddress(address)])];
        default:
            // Array type
            return encodeContractFieldArray(tpe, value);
    }
}
exports.encodeContractField = encodeContractField;
function buildDebugBytecode(bytecode, bytecodePatch) {
    if (bytecodePatch === '') {
        return bytecode;
    }
    const pattern = /[=+-][0-9a-f]*/g;
    let result = '';
    let index = 0;
    for (const parts of bytecodePatch.matchAll(pattern)) {
        const part = parts[0];
        const diffType = part[0];
        if (diffType === '=') {
            const length = parseInt(part.substring(1));
            result = result + bytecode.slice(index, index + length);
            index = index + length;
        }
        else if (diffType === '+') {
            result = result + part.substring(1);
        }
        else {
            const length = parseInt(part.substring(1));
            index = index + length;
        }
    }
    return result;
}
exports.buildDebugBytecode = buildDebugBytecode;
// export function buildContractByteCode(
//   compiled: node.TemplateContractByteCode,
//   templateVariables: TemplateVariables
// ): string {
//   const methodsBuilt = compiled.methodsByteCode.map((template) => buildByteCode(template, templateVariables))
//   let count = 0
//   const methodIndexes = methodsBuilt.map((hex) => {
//     count += hex.length / 2
//     return count
//   })
//   return (
//     binToHex(encodeI256(BigInt(compiled.filedLength))) +
//     binToHex(encodeI256(BigInt(methodIndexes.length))) +
//     methodIndexes.map((index) => binToHex(encodeI256(BigInt(index)))).join('') +
//     methodsBuilt.join('')
//   )
// }
