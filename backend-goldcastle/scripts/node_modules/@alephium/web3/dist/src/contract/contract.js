"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryGetCallResult = exports.getTokenIdFromUnsignedTx = exports.getContractIdFromUnsignedTx = exports.getContractEventsCurrentCount = exports.multicallMethods = exports.callMethod = exports.subscribeContractEvents = exports.subscribeContractEvent = exports.decodeEvent = exports.subscribeContractDestroyedEvent = exports.subscribeContractCreatedEvent = exports.fetchContractState = exports.ContractInstance = exports.testMethod = exports.addStdIdToFields = exports.subscribeEventsFromContract = exports.decodeContractDestroyedEvent = exports.decodeContractCreatedEvent = exports.DestroyContractEventAddress = exports.CreateContractEventAddress = exports.ExecutableScript = exports.ContractFactory = exports.randomTxId = exports.toApiVals = exports.Script = exports.Contract = exports.Artifact = exports.Project = exports.ProjectArtifact = exports.DEFAULT_COMPILER_OPTIONS = exports.DEFAULT_NODE_COMPILER_OPTIONS = exports.StdIdFieldName = void 0;
const buffer_1 = require("buffer/");
const fs_1 = __importDefault(require("fs"));
const fs_2 = require("fs");
const api_1 = require("../api");
const ralph = __importStar(require("./ralph"));
const utils_1 = require("../utils");
const global_1 = require("../global");
const path = __importStar(require("path"));
const events_1 = require("./events");
const constants_1 = require("../constants");
const blake = __importStar(require("blakejs"));
const error_1 = require("../utils/error");
const crypto = new utils_1.WebCrypto();
exports.StdIdFieldName = '__stdInterfaceId';
var SourceKind;
(function (SourceKind) {
    SourceKind[SourceKind["Contract"] = 0] = "Contract";
    SourceKind[SourceKind["Script"] = 1] = "Script";
    SourceKind[SourceKind["AbstractContract"] = 2] = "AbstractContract";
    SourceKind[SourceKind["Interface"] = 3] = "Interface";
})(SourceKind || (SourceKind = {}));
exports.DEFAULT_NODE_COMPILER_OPTIONS = {
    ignoreUnusedConstantsWarnings: false,
    ignoreUnusedVariablesWarnings: false,
    ignoreUnusedFieldsWarnings: false,
    ignoreUnusedPrivateFunctionsWarnings: false,
    ignoreUpdateFieldsCheckWarnings: false,
    ignoreCheckExternalCallerWarnings: false
};
exports.DEFAULT_COMPILER_OPTIONS = { errorOnWarnings: true, ...exports.DEFAULT_NODE_COMPILER_OPTIONS };
class TypedMatcher {
    constructor(pattern, type) {
        this.matcher = new RegExp(pattern, 'mg');
        this.type = type;
    }
}
function removeParentsPrefix(parts) {
    let index = 0;
    for (let i = 0; i < parts.length; i++) {
        if (parts[`${i}`] === '..') {
            index += 1;
        }
        else {
            break;
        }
    }
    return path.join(...parts.slice(index));
}
class SourceInfo {
    getArtifactPath(artifactsRootDir) {
        let fullPath;
        if (this.isExternal) {
            const relativePath = removeParentsPrefix(this.contractRelativePath.split(path.sep));
            const externalPath = path.join('.external', relativePath);
            fullPath = path.join(artifactsRootDir, externalPath);
        }
        else {
            fullPath = path.join(artifactsRootDir, this.contractRelativePath);
        }
        return path.join(path.dirname(fullPath), `${this.name}.ral.json`);
    }
    constructor(type, name, sourceCode, sourceCodeHash, contractRelativePath, isExternal) {
        this.type = type;
        this.name = name;
        this.sourceCode = sourceCode;
        this.sourceCodeHash = sourceCodeHash;
        this.contractRelativePath = contractRelativePath;
        this.isExternal = isExternal;
    }
    static async from(type, name, sourceCode, contractRelativePath, isExternal) {
        const sourceCodeHash = await crypto.subtle.digest('SHA-256', buffer_1.Buffer.from(sourceCode));
        const sourceCodeHashHex = buffer_1.Buffer.from(sourceCodeHash).toString('hex');
        return new SourceInfo(type, name, sourceCode, sourceCodeHashHex, contractRelativePath, isExternal);
    }
}
class Compiled {
    constructor(sourceInfo, artifact, warnings) {
        this.sourceInfo = sourceInfo;
        this.artifact = artifact;
        this.warnings = warnings;
    }
}
function findSourceInfoAtLineNumber(sources, line) {
    let currentLine = 0;
    const sourceInfosWithLine = sources.map((source) => {
        const startIndex = currentLine + 1;
        currentLine += source.sourceCode.split('\n').length;
        const endIndex = currentLine;
        return { sourceInfo: source, startIndex: startIndex, endIndex: endIndex };
    });
    const sourceInfo = sourceInfosWithLine.find((sourceInfoWithLine) => {
        return line >= sourceInfoWithLine.startIndex && line <= sourceInfoWithLine.endIndex;
    });
    return sourceInfo;
}
class ProjectArtifact {
    static checkCompilerOptionsParameter(compilerOptions) {
        if (Object.keys(compilerOptions).length != Object.keys(exports.DEFAULT_NODE_COMPILER_OPTIONS).length) {
            throw Error(`Not all compiler options are set: ${compilerOptions}`);
        }
        const combined = { ...compilerOptions, ...exports.DEFAULT_NODE_COMPILER_OPTIONS };
        if (Object.keys(combined).length !== Object.keys(exports.DEFAULT_NODE_COMPILER_OPTIONS).length) {
            throw Error(`There are unknown compiler options: ${compilerOptions}`);
        }
    }
    constructor(fullNodeVersion, compilerOptionsUsed, infos) {
        ProjectArtifact.checkCompilerOptionsParameter(compilerOptionsUsed);
        this.fullNodeVersion = fullNodeVersion;
        this.compilerOptionsUsed = compilerOptionsUsed;
        this.infos = infos;
    }
    static isCodeChanged(current, previous) {
        if (current.infos.size !== previous.infos.size) {
            return true;
        }
        for (const [name, codeInfo] of current.infos) {
            const prevCodeInfo = previous.infos.get(name);
            if (prevCodeInfo?.codeHashDebug !== codeInfo.codeHashDebug) {
                return true;
            }
        }
        return false;
    }
    async saveToFile(rootPath) {
        const filepath = path.join(rootPath, ProjectArtifact.artifactFileName);
        const artifact = {
            fullNodeVersion: this.fullNodeVersion,
            compilerOptionsUsed: this.compilerOptionsUsed,
            infos: Object.fromEntries(new Map([...this.infos].sort()))
        };
        const content = JSON.stringify(artifact, null, 2);
        return fs_2.promises.writeFile(filepath, content);
    }
    needToReCompile(compilerOptions, sourceInfos, fullNodeVersion) {
        ProjectArtifact.checkCompilerOptionsParameter(compilerOptions);
        if (this.fullNodeVersion !== fullNodeVersion) {
            return true;
        }
        const optionsMatched = Object.entries(compilerOptions).every(([key, inputOption]) => {
            const usedOption = this.compilerOptionsUsed[`${key}`];
            return usedOption === inputOption;
        });
        if (!optionsMatched) {
            return true;
        }
        if (sourceInfos.length !== this.infos.size) {
            return true;
        }
        for (const sourceInfo of sourceInfos) {
            const info = this.infos.get(sourceInfo.name);
            if (typeof info === 'undefined' || info.sourceCodeHash !== sourceInfo.sourceCodeHash) {
                return true;
            }
        }
        return false;
    }
    static async from(rootPath) {
        const filepath = path.join(rootPath, ProjectArtifact.artifactFileName);
        if (!fs_1.default.existsSync(filepath)) {
            return undefined;
        }
        try {
            const content = await fs_2.promises.readFile(filepath);
            const json = JSON.parse(content.toString());
            const fullNodeVersion = json.fullNodeVersion;
            const compilerOptionsUsed = json.compilerOptionsUsed;
            const files = new Map(Object.entries(json.infos));
            return new ProjectArtifact(fullNodeVersion, compilerOptionsUsed, files);
        }
        catch (error) {
            console.log(`Failed to load project artifact, error: ${error}`);
            return undefined;
        }
    }
}
exports.ProjectArtifact = ProjectArtifact;
ProjectArtifact.artifactFileName = '.project.json';
function removeOldArtifacts(dir) {
    const files = fs_1.default.readdirSync(dir);
    files.forEach((file) => {
        const filePath = path.join(dir, file);
        const stat = fs_1.default.statSync(filePath);
        if (stat.isDirectory()) {
            removeOldArtifacts(filePath);
        }
        else if (filePath.endsWith('.ral.json') || filePath.endsWith('.ral')) {
            fs_1.default.unlinkSync(filePath);
        }
    });
    if (fs_1.default.readdirSync(dir).length === 0) {
        fs_1.default.rmdirSync(dir);
    }
}
class Project {
    static buildProjectArtifact(fullNodeVersion, sourceInfos, contracts, scripts, compilerOptions) {
        const files = new Map();
        contracts.forEach((c) => {
            files.set(c.artifact.name, {
                sourceFile: c.sourceInfo.contractRelativePath,
                sourceCodeHash: c.sourceInfo.sourceCodeHash,
                bytecodeDebugPatch: c.artifact.bytecodeDebugPatch,
                codeHashDebug: c.artifact.codeHashDebug,
                warnings: c.warnings
            });
        });
        scripts.forEach((s) => {
            files.set(s.artifact.name, {
                sourceFile: s.sourceInfo.contractRelativePath,
                sourceCodeHash: s.sourceInfo.sourceCodeHash,
                bytecodeDebugPatch: s.artifact.bytecodeDebugPatch,
                codeHashDebug: '',
                warnings: s.warnings
            });
        });
        const compiledSize = contracts.size + scripts.size;
        sourceInfos.slice(compiledSize).forEach((c) => {
            files.set(c.name, {
                sourceFile: c.contractRelativePath,
                sourceCodeHash: c.sourceCodeHash,
                bytecodeDebugPatch: '',
                codeHashDebug: '',
                warnings: []
            });
        });
        return new ProjectArtifact(fullNodeVersion, compilerOptions, files);
    }
    constructor(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, errorOnWarnings, projectArtifact) {
        this.contractsRootDir = contractsRootDir;
        this.artifactsRootDir = artifactsRootDir;
        this.sourceInfos = sourceInfos;
        this.contracts = contracts;
        this.scripts = scripts;
        this.projectArtifact = projectArtifact;
        if (errorOnWarnings) {
            Project.checkCompilerWarnings([
                ...[...contracts.entries()].map((c) => c[1].warnings).flat(),
                ...[...scripts.entries()].map((s) => s[1].warnings).flat()
            ], errorOnWarnings);
        }
    }
    static checkCompilerWarnings(warnings, errorOnWarnings) {
        if (warnings.length !== 0) {
            const prefixPerWarning = '  - ';
            const warningString = prefixPerWarning + warnings.join('\n' + prefixPerWarning);
            const output = `Compilation warnings:\n` + warningString + '\n';
            if (errorOnWarnings) {
                throw new Error(output);
            }
            else {
                console.log(output);
            }
        }
    }
    static contract(name) {
        const contract = Project.currentProject.contracts.get(name);
        if (typeof contract === 'undefined') {
            throw new Error(`Contract "${name}" does not exist`);
        }
        return contract.artifact;
    }
    static script(name) {
        const script = Project.currentProject.scripts.get(name);
        if (typeof script === 'undefined') {
            throw new Error(`Script "${name}" does not exist`);
        }
        return script.artifact;
    }
    async saveArtifactsToFile(projectRootDir) {
        const artifactsRootDir = this.artifactsRootDir;
        const saveToFile = async function (compiled) {
            const artifactPath = compiled.sourceInfo.getArtifactPath(artifactsRootDir);
            const dirname = path.dirname(artifactPath);
            if (!fs_1.default.existsSync(dirname)) {
                fs_1.default.mkdirSync(dirname, { recursive: true });
            }
            return fs_2.promises.writeFile(artifactPath, compiled.artifact.toString());
        };
        this.contracts.forEach((contract) => saveToFile(contract));
        this.scripts.forEach((script) => saveToFile(script));
        await this.projectArtifact.saveToFile(projectRootDir);
    }
    contractByCodeHash(codeHash) {
        const contract = [...this.contracts.values()].find((c) => c.artifact.codeHash === codeHash || c.artifact.codeHashDebug == codeHash);
        if (typeof contract === 'undefined') {
            throw new Error(`Unknown code with code hash: ${codeHash}`);
        }
        return contract.artifact;
    }
    static async getCompileResult(provider, compilerOptions, sources) {
        try {
            const sourceStr = sources.map((f) => f.sourceCode).join('\n');
            return await provider.contracts.postContractsCompileProject({
                code: sourceStr,
                compilerOptions: compilerOptions
            });
        }
        catch (error) {
            if (!(error instanceof Error)) {
                throw error;
            }
            const parsed = (0, error_1.parseError)(error.message);
            if (!parsed) {
                throw error;
            }
            const sourceInfo = findSourceInfoAtLineNumber(sources, parsed.lineStart);
            if (!sourceInfo) {
                throw error;
            }
            const shiftIndex = parsed.lineStart - sourceInfo.startIndex + 1;
            const newError = parsed.reformat(shiftIndex, sourceInfo.sourceInfo.contractRelativePath);
            throw new Error(newError);
        }
    }
    static async compile(fullNodeVersion, provider, sourceInfos, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions) {
        const removeDuplicates = sourceInfos.reduce((acc, sourceInfo) => {
            if (acc.find((info) => info.sourceCodeHash === sourceInfo.sourceCodeHash) === undefined) {
                acc.push(sourceInfo);
            }
            return acc;
        }, []);
        const result = await Project.getCompileResult(provider, compilerOptions, removeDuplicates);
        const contracts = new Map();
        const scripts = new Map();
        result.contracts.forEach((contractResult) => {
            const sourceInfo = sourceInfos.find((sourceInfo) => sourceInfo.type === SourceKind.Contract && sourceInfo.name === contractResult.name);
            if (sourceInfo === undefined) {
                // this should never happen
                throw new Error(`SourceInfo does not exist for contract ${contractResult.name}`);
            }
            const contract = Contract.fromCompileResult(contractResult);
            contracts.set(contract.name, new Compiled(sourceInfo, contract, contractResult.warnings));
        });
        result.scripts.forEach((scriptResult) => {
            const sourceInfo = sourceInfos.find((sourceInfo) => sourceInfo.type === SourceKind.Script && sourceInfo.name === scriptResult.name);
            if (sourceInfo === undefined) {
                // this should never happen
                throw new Error(`SourceInfo does not exist for script ${scriptResult.name}`);
            }
            const script = Script.fromCompileResult(scriptResult);
            scripts.set(script.name, new Compiled(sourceInfo, script, scriptResult.warnings));
        });
        const projectArtifact = Project.buildProjectArtifact(fullNodeVersion, sourceInfos, contracts, scripts, compilerOptions);
        const project = new Project(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, errorOnWarnings, projectArtifact);
        await project.saveArtifactsToFile(projectRootDir);
        return project;
    }
    static async loadArtifacts(provider, sourceInfos, projectArtifact, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions) {
        try {
            const contracts = new Map();
            const scripts = new Map();
            for (const sourceInfo of sourceInfos) {
                const info = projectArtifact.infos.get(sourceInfo.name);
                if (typeof info === 'undefined') {
                    throw Error(`Unable to find project info for ${sourceInfo.name}, please rebuild the project`);
                }
                const warnings = info.warnings;
                const artifactDir = sourceInfo.getArtifactPath(artifactsRootDir);
                if (sourceInfo.type === SourceKind.Contract) {
                    const artifact = await Contract.fromArtifactFile(artifactDir, info.bytecodeDebugPatch, info.codeHashDebug);
                    contracts.set(artifact.name, new Compiled(sourceInfo, artifact, warnings));
                }
                else if (sourceInfo.type === SourceKind.Script) {
                    const artifact = await Script.fromArtifactFile(artifactDir, info.bytecodeDebugPatch);
                    scripts.set(artifact.name, new Compiled(sourceInfo, artifact, warnings));
                }
            }
            return new Project(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, errorOnWarnings, projectArtifact);
        }
        catch (error) {
            console.log(`Failed to load artifacts, error: ${error}, try to re-compile contracts...`);
            return Project.compile(projectArtifact.fullNodeVersion, provider, sourceInfos, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions);
        }
    }
    static getImportSourcePath(projectRootDir, importPath) {
        const parts = importPath.split('/');
        if (parts.length > 1 && parts[0] === 'std') {
            const currentDir = path.dirname(__filename);
            return path.join(...[currentDir, '..', '..', '..', importPath]);
        }
        let moduleDir = projectRootDir;
        while (true) {
            const expectedPath = path.join(...[moduleDir, 'node_modules', importPath]);
            if (fs_1.default.existsSync(expectedPath)) {
                return expectedPath;
            }
            const oldModuleDir = moduleDir;
            moduleDir = path.join(moduleDir, '..');
            if (oldModuleDir === moduleDir) {
                throw new Error(`Specified import file does not exist: ${importPath}`);
            }
        }
    }
    static async handleImports(projectRootDir, contractRootDir, sourceStr, importsCache) {
        const localImportsCache = [];
        const result = sourceStr.replace(Project.importRegex, (match) => {
            localImportsCache.push(match);
            return '';
        });
        const externalSourceInfos = [];
        for (const myImport of localImportsCache) {
            const originImportPath = myImport.slice(8, -1);
            const importPath = originImportPath.endsWith('.ral') ? originImportPath : originImportPath + '.ral';
            if (!importsCache.includes(importPath)) {
                importsCache.push(importPath);
                const sourcePath = Project.getImportSourcePath(projectRootDir, importPath);
                const sourceInfos = await Project.loadSourceFile(projectRootDir, contractRootDir, sourcePath, importsCache, true);
                externalSourceInfos.push(...sourceInfos);
            }
        }
        return [result, externalSourceInfos];
    }
    static async loadSourceFile(projectRootDir, contractsRootDir, sourcePath, importsCache, isExternal) {
        const contractRelativePath = path.relative(contractsRootDir, sourcePath);
        if (!sourcePath.endsWith('.ral')) {
            throw new Error(`Invalid filename: ${sourcePath}, smart contract file name should end with ".ral"`);
        }
        const sourceBuffer = await fs_2.promises.readFile(sourcePath);
        const [sourceStr, externalSourceInfos] = await Project.handleImports(projectRootDir, contractsRootDir, sourceBuffer.toString(), importsCache);
        if (sourceStr.match(new RegExp('^import "', 'mg')) !== null) {
            throw new Error(`Invalid import statements, source: ${sourcePath}`);
        }
        const sourceInfos = externalSourceInfos;
        for (const matcher of this.matchers) {
            const results = sourceStr.matchAll(matcher.matcher);
            for (const result of results) {
                const sourceInfo = await SourceInfo.from(matcher.type, result[1], sourceStr, contractRelativePath, isExternal);
                sourceInfos.push(sourceInfo);
            }
        }
        return sourceInfos;
    }
    static async loadSourceFiles(projectRootDir, contractsRootDir) {
        const importsCache = [];
        const sourceInfos = [];
        const loadDir = async function (dirPath) {
            const dirents = await fs_2.promises.readdir(dirPath, { withFileTypes: true });
            for (const dirent of dirents) {
                if (dirent.isFile()) {
                    const sourcePath = path.join(dirPath, dirent.name);
                    const infos = await Project.loadSourceFile(projectRootDir, contractsRootDir, sourcePath, importsCache, false);
                    sourceInfos.push(...infos);
                }
                else {
                    const newPath = path.join(dirPath, dirent.name);
                    await loadDir(newPath);
                }
            }
        };
        await loadDir(contractsRootDir);
        const contractAndScriptSize = sourceInfos.filter((f) => f.type === SourceKind.Contract || f.type === SourceKind.Script).length;
        if (sourceInfos.length === 0 || contractAndScriptSize === 0) {
            throw new Error('Project have no source files');
        }
        return sourceInfos.sort((a, b) => a.type - b.type);
    }
    static async build(compilerOptionsPartial = {}, projectRootDir = '.', contractsRootDir = Project.DEFAULT_CONTRACTS_DIR, artifactsRootDir = Project.DEFAULT_ARTIFACTS_DIR, defaultFullNodeVersion = undefined) {
        const provider = (0, global_1.getCurrentNodeProvider)();
        const fullNodeVersion = defaultFullNodeVersion ?? (await provider.infos.getInfosVersion()).version;
        const sourceFiles = await Project.loadSourceFiles(projectRootDir, contractsRootDir);
        const { errorOnWarnings, ...nodeCompilerOptions } = { ...exports.DEFAULT_COMPILER_OPTIONS, ...compilerOptionsPartial };
        const projectArtifact = await ProjectArtifact.from(projectRootDir);
        if (projectArtifact === undefined ||
            projectArtifact.needToReCompile(nodeCompilerOptions, sourceFiles, fullNodeVersion)) {
            if (fs_1.default.existsSync(artifactsRootDir)) {
                removeOldArtifacts(artifactsRootDir);
            }
            console.log(`Compiling contracts in folder "${contractsRootDir}"`);
            Project.currentProject = await Project.compile(fullNodeVersion, provider, sourceFiles, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, nodeCompilerOptions);
        }
        else {
            console.log(`Contracts are compiled already. Loading them from folder "${artifactsRootDir}"`);
            Project.currentProject = await Project.loadArtifacts(provider, sourceFiles, projectArtifact, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, nodeCompilerOptions);
        }
    }
}
exports.Project = Project;
Project.importRegex = new RegExp('^import "[^"./]+/[^"]*[a-z][a-z_0-9]*(.ral)?"', 'mg');
Project.abstractContractMatcher = new TypedMatcher('^Abstract Contract ([A-Z][a-zA-Z0-9]*)', SourceKind.AbstractContract);
Project.contractMatcher = new TypedMatcher('^Contract ([A-Z][a-zA-Z0-9]*)', SourceKind.Contract);
Project.interfaceMatcher = new TypedMatcher('^Interface ([A-Z][a-zA-Z0-9]*)', SourceKind.Interface);
Project.scriptMatcher = new TypedMatcher('^TxScript ([A-Z][a-zA-Z0-9]*)', SourceKind.Script);
Project.matchers = [
    Project.abstractContractMatcher,
    Project.contractMatcher,
    Project.interfaceMatcher,
    Project.scriptMatcher
];
Project.DEFAULT_CONTRACTS_DIR = 'contracts';
Project.DEFAULT_ARTIFACTS_DIR = 'artifacts';
class Artifact {
    constructor(version, name, functions) {
        this.version = version;
        this.name = name;
        this.functions = functions;
    }
    publicFunctions() {
        return this.functions.filter((func) => func.isPublic).map((func) => func.name);
    }
    usingPreapprovedAssetsFunctions() {
        return this.functions.filter((func) => func.usePreapprovedAssets).map((func) => func.name);
    }
    usingAssetsInContractFunctions() {
        return this.functions.filter((func) => func.useAssetsInContract).map((func) => func.name);
    }
    async isDevnet(signer) {
        if (!signer.nodeProvider) {
            return false;
        }
        const chainParams = await signer.nodeProvider.infos.getInfosChainParams();
        return (0, utils_1.isDevnet)(chainParams.networkId);
    }
}
exports.Artifact = Artifact;
class Contract extends Artifact {
    constructor(version, name, bytecode, bytecodeDebugPatch, codeHash, codeHashDebug, fieldsSig, eventsSig, functions, constants, enums, stdInterfaceId) {
        super(version, name, functions);
        this.bytecode = bytecode;
        this.bytecodeDebugPatch = bytecodeDebugPatch;
        this.codeHash = codeHash;
        this.fieldsSig = fieldsSig;
        this.eventsSig = eventsSig;
        this.constants = constants;
        this.enums = enums;
        this.stdInterfaceId = stdInterfaceId;
        this.bytecodeDebug = ralph.buildDebugBytecode(this.bytecode, this.bytecodeDebugPatch);
        this.codeHashDebug = codeHashDebug;
    }
    // TODO: safely parse json
    static fromJson(artifact, bytecodeDebugPatch = '', codeHashDebug = '') {
        if (artifact.version == null ||
            artifact.name == null ||
            artifact.bytecode == null ||
            artifact.codeHash == null ||
            artifact.fieldsSig == null ||
            artifact.eventsSig == null ||
            artifact.constants == null ||
            artifact.enums == null ||
            artifact.functions == null) {
            throw Error('The artifact JSON for contract is incomplete');
        }
        const contract = new Contract(artifact.version, artifact.name, artifact.bytecode, bytecodeDebugPatch, artifact.codeHash, codeHashDebug ? codeHashDebug : artifact.codeHash, artifact.fieldsSig, artifact.eventsSig, artifact.functions, artifact.constants, artifact.enums, artifact.stdInterfaceId === null ? undefined : artifact.stdInterfaceId);
        return contract;
    }
    static fromCompileResult(result) {
        return new Contract(result.version, result.name, result.bytecode, result.bytecodeDebugPatch, result.codeHash, result.codeHashDebug, result.fields, result.events, result.functions, result.constants, result.enums, result.stdInterfaceId);
    }
    // support both 'code.ral' and 'code.ral.json'
    static async fromArtifactFile(path, bytecodeDebugPatch, codeHashDebug) {
        const content = await fs_2.promises.readFile(path);
        const artifact = JSON.parse(content.toString());
        return Contract.fromJson(artifact, bytecodeDebugPatch, codeHashDebug);
    }
    toString() {
        const object = {
            version: this.version,
            name: this.name,
            bytecode: this.bytecode,
            codeHash: this.codeHash,
            fieldsSig: this.fieldsSig,
            eventsSig: this.eventsSig,
            functions: this.functions,
            constants: this.constants,
            enums: this.enums
        };
        if (this.stdInterfaceId !== undefined) {
            object.stdInterfaceId = this.stdInterfaceId;
        }
        return JSON.stringify(object, null, 2);
    }
    getInitialFieldsWithDefaultValues() {
        const fields = this.stdInterfaceId === undefined
            ? this.fieldsSig
            : {
                names: this.fieldsSig.names.slice(0, -1),
                types: this.fieldsSig.types.slice(0, -1),
                isMutable: this.fieldsSig.isMutable.slice(0, -1)
            };
        return fields.names.reduce((acc, key, index) => {
            acc[`${key}`] = (0, api_1.getDefaultValue)(fields.types[`${index}`]);
            return acc;
        }, {});
    }
    toState(fields, asset, address) {
        const addressDef = typeof address !== 'undefined' ? address : Contract.randomAddress();
        return {
            address: addressDef,
            contractId: (0, utils_1.binToHex)((0, utils_1.contractIdFromAddress)(addressDef)),
            bytecode: this.bytecode,
            codeHash: this.codeHash,
            fields: fields,
            fieldsSig: this.fieldsSig,
            asset: asset
        };
    }
    // no need to be cryptographically strong random
    static randomAddress() {
        const bytes = new Uint8Array(33);
        crypto.getRandomValues(bytes);
        bytes[0] = 3;
        return utils_1.bs58.encode(bytes);
    }
    printDebugMessages(funcName, messages) {
        if (messages.length != 0) {
            console.log(`Testing ${this.name}.${funcName}:`);
            messages.forEach((m) => console.log(`> Contract @ ${m.contractAddress} - ${m.message}`));
        }
    }
    toApiFields(fields) {
        if (typeof fields === 'undefined') {
            return [];
        }
        else {
            return toApiFields(fields, this.fieldsSig);
        }
    }
    toApiArgs(funcName, args) {
        if (args) {
            const func = this.functions.find((func) => func.name == funcName);
            if (func == null) {
                throw new Error(`Invalid function name: ${funcName}`);
            }
            return toApiArgs(args, func);
        }
        else {
            return [];
        }
    }
    getMethodIndex(funcName) {
        return this.functions.findIndex((func) => func.name === funcName);
    }
    toApiContractStates(states) {
        return typeof states != 'undefined' ? states.map((state) => toApiContractState(state)) : undefined;
    }
    toApiTestContractParams(funcName, params) {
        const immFields = params.initialFields === undefined ? [] : extractFields(params.initialFields, this.fieldsSig, false);
        const mutFields = params.initialFields === undefined ? [] : extractFields(params.initialFields, this.fieldsSig, true);
        return {
            group: params.group,
            blockHash: params.blockHash,
            blockTimeStamp: params.blockTimeStamp,
            txId: params.txId,
            address: params.address,
            callerAddress: params.callerAddress,
            bytecode: this.bytecodeDebug,
            initialImmFields: immFields,
            initialMutFields: mutFields,
            initialAsset: typeof params.initialAsset !== 'undefined' ? toApiAsset(params.initialAsset) : undefined,
            methodIndex: this.getMethodIndex(funcName),
            args: this.toApiArgs(funcName, params.testArgs),
            existingContracts: this.toApiContractStates(params.existingContracts),
            inputAssets: toApiInputAssets(params.inputAssets)
        };
    }
    fromApiContractState(state) {
        return {
            address: state.address,
            contractId: (0, utils_1.binToHex)((0, utils_1.contractIdFromAddress)(state.address)),
            bytecode: state.bytecode,
            initialStateHash: state.initialStateHash,
            codeHash: state.codeHash,
            fields: fromApiFields(state.immFields, state.mutFields, this.fieldsSig),
            fieldsSig: this.fieldsSig,
            asset: fromApiAsset(state.asset)
        };
    }
    static fromApiContractState(state, getContractByCodeHash) {
        const contract = getContractByCodeHash
            ? getContractByCodeHash(state.codeHash)
            : Project.currentProject.contractByCodeHash(state.codeHash);
        return contract.fromApiContractState(state);
    }
    static fromApiEvent(event, codeHash, txId, getContractByCodeHash) {
        let fields;
        let name;
        if (event.eventIndex == Contract.ContractCreatedEventIndex) {
            fields = toContractCreatedEventFields(fromApiEventFields(event.fields, Contract.ContractCreatedEvent, true));
            name = Contract.ContractCreatedEvent.name;
        }
        else if (event.eventIndex == Contract.ContractDestroyedEventIndex) {
            fields = fromApiEventFields(event.fields, Contract.ContractDestroyedEvent, true);
            name = Contract.ContractDestroyedEvent.name;
        }
        else {
            const contract = getContractByCodeHash
                ? getContractByCodeHash(codeHash)
                : Project.currentProject.contractByCodeHash(codeHash);
            const eventSig = contract.eventsSig[event.eventIndex];
            fields = fromApiEventFields(event.fields, eventSig);
            name = eventSig.name;
        }
        return {
            txId: txId,
            blockHash: event.blockHash,
            contractAddress: event.contractAddress,
            name: name,
            eventIndex: event.eventIndex,
            fields: fields
        };
    }
    fromApiTestContractResult(methodName, result, txId) {
        const methodIndex = this.functions.findIndex((sig) => sig.name === methodName);
        const returnTypes = this.functions[`${methodIndex}`].returnTypes;
        const rawReturn = (0, api_1.fromApiArray)(result.returns, returnTypes);
        const returns = rawReturn.length === 0 ? null : rawReturn.length === 1 ? rawReturn[0] : rawReturn;
        const addressToCodeHash = new Map();
        addressToCodeHash.set(result.address, result.codeHash);
        result.contracts.forEach((contract) => addressToCodeHash.set(contract.address, contract.codeHash));
        return {
            contractId: (0, utils_1.binToHex)((0, utils_1.contractIdFromAddress)(result.address)),
            contractAddress: result.address,
            returns: returns,
            gasUsed: result.gasUsed,
            contracts: result.contracts.map((contract) => Contract.fromApiContractState(contract)),
            txOutputs: result.txOutputs.map(fromApiOutput),
            events: Contract.fromApiEvents(result.events, addressToCodeHash, txId),
            debugMessages: result.debugMessages
        };
    }
    async txParamsForDeployment(signer, params) {
        const isDevnet = await this.isDevnet(signer);
        const initialFields = params.initialFields ?? {};
        const bytecode = this.buildByteCodeToDeploy(addStdIdToFields(this, initialFields), isDevnet);
        const selectedAccount = await signer.getSelectedAccount();
        const signerParams = {
            signerAddress: selectedAccount.address,
            signerKeyType: selectedAccount.keyType,
            bytecode: bytecode,
            initialAttoAlphAmount: params?.initialAttoAlphAmount,
            issueTokenAmount: params?.issueTokenAmount,
            initialTokenAmounts: params?.initialTokenAmounts,
            gasAmount: params?.gasAmount,
            gasPrice: params?.gasPrice
        };
        return signerParams;
    }
    buildByteCodeToDeploy(initialFields, isDevnet) {
        try {
            return ralph.buildContractByteCode(isDevnet ? this.bytecodeDebug : this.bytecode, initialFields, this.fieldsSig);
        }
        catch (error) {
            throw new Error(`Failed to build bytecode for contract ${this.name}, error: ${error}`);
        }
    }
    static fromApiEvents(events, addressToCodeHash, txId, getContractByCodeHash) {
        return events.map((event) => {
            const contractAddress = event.contractAddress;
            const codeHash = addressToCodeHash.get(contractAddress);
            if (typeof codeHash !== 'undefined' || event.eventIndex < 0) {
                return Contract.fromApiEvent(event, codeHash, txId, getContractByCodeHash);
            }
            else {
                throw Error(`Cannot find codeHash for the contract address: ${contractAddress}`);
            }
        });
    }
    toApiCallContract(params, groupIndex, contractAddress, methodIndex) {
        const functionSig = this.functions[`${methodIndex}`];
        const args = toApiVals(params.args ?? {}, functionSig.paramNames, functionSig.paramTypes);
        return {
            ...params,
            group: groupIndex,
            address: contractAddress,
            methodIndex: methodIndex,
            args: args
        };
    }
    fromApiCallContractResult(result, txId, methodIndex, getContractByCodeHash) {
        const returnTypes = this.functions[`${methodIndex}`].returnTypes;
        const callResult = tryGetCallResult(result);
        const rawReturn = (0, api_1.fromApiArray)(callResult.returns, returnTypes);
        const returns = rawReturn.length === 0 ? null : rawReturn.length === 1 ? rawReturn[0] : rawReturn;
        const addressToCodeHash = new Map();
        callResult.contracts.forEach((contract) => addressToCodeHash.set(contract.address, contract.codeHash));
        return {
            returns: returns,
            gasUsed: callResult.gasUsed,
            contracts: callResult.contracts.map((state) => Contract.fromApiContractState(state, getContractByCodeHash)),
            txInputs: callResult.txInputs,
            txOutputs: callResult.txOutputs.map((output) => fromApiOutput(output)),
            events: Contract.fromApiEvents(callResult.events, addressToCodeHash, txId, getContractByCodeHash),
            debugMessages: callResult.debugMessages
        };
    }
}
exports.Contract = Contract;
Contract.ContractCreatedEventIndex = -1;
Contract.ContractCreatedEvent = {
    name: 'ContractCreated',
    fieldNames: ['address', 'parentAddress', 'stdInterfaceId'],
    fieldTypes: ['Address', 'Address', 'ByteVec']
};
Contract.ContractDestroyedEventIndex = -2;
Contract.ContractDestroyedEvent = {
    name: 'ContractDestroyed',
    fieldNames: ['address'],
    fieldTypes: ['Address']
};
class Script extends Artifact {
    constructor(version, name, bytecodeTemplate, bytecodeDebugPatch, fieldsSig, functions) {
        super(version, name, functions);
        this.bytecodeTemplate = bytecodeTemplate;
        this.bytecodeDebugPatch = bytecodeDebugPatch;
        this.fieldsSig = fieldsSig;
    }
    static fromCompileResult(result) {
        return new Script(result.version, result.name, result.bytecodeTemplate, result.bytecodeDebugPatch, result.fields, result.functions);
    }
    // TODO: safely parse json
    static fromJson(artifact, bytecodeDebugPatch = '') {
        if (artifact.version == null ||
            artifact.name == null ||
            artifact.bytecodeTemplate == null ||
            artifact.fieldsSig == null ||
            artifact.functions == null) {
            throw Error('The artifact JSON for script is incomplete');
        }
        return new Script(artifact.version, artifact.name, artifact.bytecodeTemplate, bytecodeDebugPatch, artifact.fieldsSig, artifact.functions);
    }
    static async fromArtifactFile(path, bytecodeDebugPatch) {
        const content = await fs_2.promises.readFile(path);
        const artifact = JSON.parse(content.toString());
        return this.fromJson(artifact, bytecodeDebugPatch);
    }
    toString() {
        const object = {
            version: this.version,
            name: this.name,
            bytecodeTemplate: this.bytecodeTemplate,
            fieldsSig: this.fieldsSig,
            functions: this.functions
        };
        return JSON.stringify(object, null, 2);
    }
    async txParamsForExecution(signer, params) {
        const selectedAccount = await signer.getSelectedAccount();
        const signerParams = {
            signerAddress: selectedAccount.address,
            signerKeyType: selectedAccount.keyType,
            bytecode: this.buildByteCodeToDeploy(params.initialFields ?? {}),
            attoAlphAmount: params.attoAlphAmount,
            tokens: params.tokens,
            gasAmount: params.gasAmount,
            gasPrice: params.gasPrice
        };
        return signerParams;
    }
    buildByteCodeToDeploy(initialFields) {
        try {
            return ralph.buildScriptByteCode(this.bytecodeTemplate, initialFields, this.fieldsSig);
        }
        catch (error) {
            throw new Error(`Failed to build bytecode for script ${this.name}, error: ${error}`);
        }
    }
}
exports.Script = Script;
function fromApiFields(immFields, mutFields, fieldsSig) {
    const vals = [];
    let immIndex = 0;
    let mutIndex = 0;
    const isMutable = fieldsSig.types.flatMap((tpe, index) => Array((0, api_1.typeLength)(tpe)).fill(fieldsSig.isMutable[`${index}`]));
    isMutable.forEach((mutable) => {
        if (mutable) {
            vals.push(mutFields[`${mutIndex}`]);
            mutIndex += 1;
        }
        else {
            vals.push(immFields[`${immIndex}`]);
            immIndex += 1;
        }
    });
    return (0, api_1.fromApiVals)(vals, fieldsSig.names, fieldsSig.types);
}
function fromApiEventFields(vals, eventSig, systemEvent = false) {
    return (0, api_1.fromApiVals)(vals, eventSig.fieldNames, eventSig.fieldTypes, systemEvent);
}
function toApiAsset(asset) {
    return {
        attoAlphAmount: (0, api_1.toApiNumber256)(asset.alphAmount),
        tokens: typeof asset.tokens !== 'undefined' ? asset.tokens.map(api_1.toApiToken) : []
    };
}
function fromApiAsset(asset) {
    return {
        alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
        tokens: (0, api_1.fromApiTokens)(asset.tokens)
    };
}
function getVal(vals, name) {
    if (name in vals) {
        return vals[`${name}`];
    }
    else {
        throw Error(`No Val exists for ${name}`);
    }
}
function extractFields(fields, fieldsSig, mutable) {
    const fieldIndexes = fieldsSig.names
        .map((_, index) => index)
        .filter((index) => fieldsSig.isMutable[`${index}`] === mutable);
    const fieldNames = fieldIndexes.map((index) => fieldsSig.names[`${index}`]);
    const fieldTypes = fieldIndexes.map((index) => fieldsSig.types[`${index}`]);
    return toApiVals(fields, fieldNames, fieldTypes);
}
function toApiContractState(state) {
    const stateFields = state.fields ?? {};
    return {
        address: state.address,
        bytecode: state.bytecode,
        codeHash: state.codeHash,
        initialStateHash: state.initialStateHash,
        immFields: extractFields(stateFields, state.fieldsSig, false),
        mutFields: extractFields(stateFields, state.fieldsSig, true),
        asset: toApiAsset(state.asset)
    };
}
function toApiFields(fields, fieldsSig) {
    return toApiVals(fields, fieldsSig.names, fieldsSig.types);
}
function toApiArgs(args, funcSig) {
    return toApiVals(args, funcSig.paramNames, funcSig.paramTypes);
}
function toApiVals(fields, names, types) {
    return names.map((name, index) => {
        const val = getVal(fields, name);
        const tpe = types[`${index}`];
        return (0, api_1.toApiVal)(val, tpe);
    });
}
exports.toApiVals = toApiVals;
function toApiInputAsset(inputAsset) {
    return { address: inputAsset.address, asset: toApiAsset(inputAsset.asset) };
}
function toApiInputAssets(inputAssets) {
    return typeof inputAssets !== 'undefined' ? inputAssets.map(toApiInputAsset) : undefined;
}
function fromApiOutput(output) {
    if (output.type === 'AssetOutput') {
        const asset = output;
        return {
            type: 'AssetOutput',
            address: asset.address,
            alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
            tokens: (0, api_1.fromApiTokens)(asset.tokens),
            lockTime: asset.lockTime,
            message: asset.message
        };
    }
    else if (output.type === 'ContractOutput') {
        const asset = output;
        return {
            type: 'ContractOutput',
            address: asset.address,
            alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
            tokens: (0, api_1.fromApiTokens)(asset.tokens)
        };
    }
    else {
        throw new Error(`Unknown output type: ${output}`);
    }
}
function randomTxId() {
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    return (0, utils_1.binToHex)(bytes);
}
exports.randomTxId = randomTxId;
utils_1.assertType;
class ContractFactory {
    constructor(contract) {
        this.contract = contract;
    }
    async deploy(signer, deployParams) {
        const signerParams = await this.contract.txParamsForDeployment(signer, {
            ...deployParams,
            initialFields: addStdIdToFields(this.contract, deployParams.initialFields)
        });
        const result = await signer.signAndSubmitDeployContractTx(signerParams);
        return {
            ...result,
            contractInstance: this.at(result.contractAddress)
        };
    }
    // This is used for testing contract functions
    stateForTest(initFields, asset, address) {
        const newAsset = {
            alphAmount: asset?.alphAmount ?? constants_1.ONE_ALPH,
            tokens: asset?.tokens
        };
        return this.contract.toState(addStdIdToFields(this.contract, initFields), newAsset, address);
    }
}
exports.ContractFactory = ContractFactory;
class ExecutableScript {
    constructor(script) {
        this.script = script;
    }
    async execute(signer, params) {
        const signerParams = await this.script.txParamsForExecution(signer, params);
        return await signer.signAndSubmitExecuteScriptTx(signerParams);
    }
}
exports.ExecutableScript = ExecutableScript;
function specialContractAddress(n) {
    const bytes = new Uint8Array(32).fill(0);
    bytes[31] = n;
    return (0, utils_1.addressFromContractId)((0, utils_1.binToHex)(bytes));
}
exports.CreateContractEventAddress = specialContractAddress(-1);
exports.DestroyContractEventAddress = specialContractAddress(-2);
function decodeSystemEvent(event, eventSig, eventIndex) {
    if (event.eventIndex !== eventIndex) {
        throw new Error(`Invalid event index: ${event.eventIndex}, expected: ${eventIndex}`);
    }
    return fromApiEventFields(event.fields, eventSig, true);
}
function toContractCreatedEventFields(fields) {
    const parentAddress = fields['parentAddress'];
    const stdInterfaceId = fields['stdInterfaceId'];
    return {
        address: fields['address'],
        parentAddress: parentAddress === '' ? undefined : parentAddress,
        stdInterfaceIdGuessed: stdInterfaceId === '' ? undefined : stdInterfaceId
    };
}
function decodeContractCreatedEvent(event) {
    const fields = decodeSystemEvent(event, Contract.ContractCreatedEvent, Contract.ContractCreatedEventIndex);
    return {
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: Contract.ContractCreatedEvent.name,
        fields: toContractCreatedEventFields(fields)
    };
}
exports.decodeContractCreatedEvent = decodeContractCreatedEvent;
function decodeContractDestroyedEvent(event) {
    const fields = decodeSystemEvent(event, Contract.ContractDestroyedEvent, Contract.ContractDestroyedEventIndex);
    return {
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: Contract.ContractDestroyedEvent.name,
        fields: { address: fields['address'] }
    };
}
exports.decodeContractDestroyedEvent = decodeContractDestroyedEvent;
function subscribeEventsFromContract(options, address, eventIndex, decodeFunc, fromCount) {
    const messageCallback = (event) => {
        if (event.eventIndex !== eventIndex) {
            return Promise.resolve();
        }
        return options.messageCallback(decodeFunc(event));
    };
    const errorCallback = (err, subscription) => {
        return options.errorCallback(err, subscription);
    };
    const opt = {
        pollingInterval: options.pollingInterval,
        messageCallback: messageCallback,
        errorCallback: errorCallback,
        onEventCountChanged: options.onEventCountChanged
    };
    return (0, events_1.subscribeToEvents)(opt, address, fromCount);
}
exports.subscribeEventsFromContract = subscribeEventsFromContract;
function addStdIdToFields(contract, fields) {
    const stdInterfaceIdPrefix = '414c5048'; // the hex of 'ALPH'
    return contract.stdInterfaceId === undefined
        ? fields
        : { ...fields, __stdInterfaceId: stdInterfaceIdPrefix + contract.stdInterfaceId };
}
exports.addStdIdToFields = addStdIdToFields;
async function testMethod(contract, methodName, params) {
    const txId = params?.txId ?? randomTxId();
    const initialFields = params.initialFields === undefined ? {} : params.initialFields;
    const apiParams = contract.contract.toApiTestContractParams(methodName, {
        ...params,
        txId: txId,
        initialFields: addStdIdToFields(contract.contract, initialFields),
        testArgs: params.testArgs === undefined ? {} : params.testArgs
    });
    const apiResult = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsTestContract(apiParams);
    const testResult = contract.contract.fromApiTestContractResult(methodName, apiResult, txId);
    contract.contract.printDebugMessages(methodName, testResult.debugMessages);
    return testResult;
}
exports.testMethod = testMethod;
class ContractInstance {
    constructor(address) {
        this.address = address;
        this.contractId = (0, utils_1.binToHex)((0, utils_1.contractIdFromAddress)(address));
        this.groupIndex = (0, utils_1.groupOfAddress)(address);
    }
}
exports.ContractInstance = ContractInstance;
async function fetchContractState(contract, instance) {
    const contractState = await (0, global_1.getCurrentNodeProvider)().contracts.getContractsAddressState(instance.address);
    const state = contract.contract.fromApiContractState(contractState);
    return {
        ...state,
        fields: state.fields
    };
}
exports.fetchContractState = fetchContractState;
function subscribeContractCreatedEvent(options, fromCount) {
    return subscribeEventsFromContract(options, exports.CreateContractEventAddress, Contract.ContractCreatedEventIndex, (event) => {
        return {
            ...decodeContractCreatedEvent(event),
            contractAddress: exports.CreateContractEventAddress
        };
    }, fromCount);
}
exports.subscribeContractCreatedEvent = subscribeContractCreatedEvent;
function subscribeContractDestroyedEvent(options, fromCount) {
    return subscribeEventsFromContract(options, exports.DestroyContractEventAddress, Contract.ContractDestroyedEventIndex, (event) => {
        return {
            ...decodeContractDestroyedEvent(event),
            contractAddress: exports.DestroyContractEventAddress
        };
    }, fromCount);
}
exports.subscribeContractDestroyedEvent = subscribeContractDestroyedEvent;
function decodeEvent(contract, instance, event, targetEventIndex) {
    if (event.eventIndex !== targetEventIndex &&
        !(targetEventIndex >= 0 && targetEventIndex < contract.eventsSig.length)) {
        throw new Error('Invalid event index: ' + event.eventIndex + ', expected: ' + targetEventIndex);
    }
    const eventSig = contract.eventsSig[`${targetEventIndex}`];
    const fieldNames = eventSig.fieldNames;
    const fieldTypes = eventSig.fieldTypes;
    const fields = (0, api_1.fromApiVals)(event.fields, fieldNames, fieldTypes);
    return {
        contractAddress: instance.address,
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: eventSig.name,
        fields: fields
    };
}
exports.decodeEvent = decodeEvent;
function subscribeContractEvent(contract, instance, options, eventName, fromCount) {
    const eventIndex = contract.eventsSig.findIndex((sig) => sig.name === eventName);
    return subscribeEventsFromContract(options, instance.address, eventIndex, (event) => decodeEvent(contract, instance, event, eventIndex), fromCount);
}
exports.subscribeContractEvent = subscribeContractEvent;
function subscribeContractEvents(contract, instance, options, fromCount) {
    const messageCallback = (event) => {
        return options.messageCallback({
            ...decodeEvent(contract, instance, event, event.eventIndex),
            contractAddress: instance.address
        });
    };
    const errorCallback = (err, subscription) => {
        return options.errorCallback(err, subscription);
    };
    const opt = {
        pollingInterval: options.pollingInterval,
        messageCallback: messageCallback,
        errorCallback: errorCallback,
        onEventCountChanged: options.onEventCountChanged
    };
    return (0, events_1.subscribeToEvents)(opt, instance.address, fromCount);
}
exports.subscribeContractEvents = subscribeContractEvents;
async function callMethod(contract, instance, methodName, params, getContractByCodeHash) {
    const methodIndex = contract.contract.getMethodIndex(methodName);
    const txId = params?.txId ?? randomTxId();
    const callParams = contract.contract.toApiCallContract({ ...params, txId: txId, args: params.args === undefined ? {} : params.args }, instance.groupIndex, instance.address, methodIndex);
    const result = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsCallContract(callParams);
    const callResult = contract.contract.fromApiCallContractResult(result, txId, methodIndex, getContractByCodeHash);
    contract.contract.printDebugMessages(methodName, callResult.debugMessages);
    return callResult;
}
exports.callMethod = callMethod;
async function multicallMethods(contract, instance, calls, getContractByCodeHash) {
    const callEntries = Object.entries(calls);
    const callsParams = callEntries.map((entry) => {
        const [methodName, params] = entry;
        const methodIndex = contract.contract.getMethodIndex(methodName);
        const txId = params?.txId ?? randomTxId();
        return contract.contract.toApiCallContract({ ...params, txId: txId, args: params.args === undefined ? {} : params.args }, instance.groupIndex, instance.address, methodIndex);
    });
    const result = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsMulticallContract({ calls: callsParams });
    const callsResult = {};
    callsParams.forEach((call, index) => {
        const methodIndex = call.methodIndex;
        const callResult = result.results[`${methodIndex}`];
        const methodName = callEntries[`${index}`][`0`];
        callsResult[`${methodName}`] = contract.contract.fromApiCallContractResult(callResult, call.txId, methodIndex, getContractByCodeHash);
    });
    return callsResult;
}
exports.multicallMethods = multicallMethods;
async function getContractEventsCurrentCount(contractAddress) {
    return (0, global_1.getCurrentNodeProvider)()
        .events.getEventsContractContractaddressCurrentCount(contractAddress)
        .catch((error) => {
        if (error instanceof Error && error.message.includes(`${contractAddress} not found`)) {
            return 0;
        }
        throw error;
    });
}
exports.getContractEventsCurrentCount = getContractEventsCurrentCount;
// This function only works in the simple case where a single non-subcontract is created in the tx
const getContractIdFromUnsignedTx = async (nodeProvider, unsignedTx) => {
    const result = await nodeProvider.transactions.postTransactionsDecodeUnsignedTx({ unsignedTx });
    const outputIndex = result.unsignedTx.fixedOutputs.length;
    const hex = result.unsignedTx.txId + outputIndex.toString(16).padStart(8, '0');
    const hashHex = (0, utils_1.binToHex)(blake.blake2b((0, utils_1.hexToBinUnsafe)(hex), undefined, 32));
    return hashHex.slice(0, 62) + result.fromGroup.toString(16).padStart(2, '0');
};
exports.getContractIdFromUnsignedTx = getContractIdFromUnsignedTx;
// This function only works in the simple case where a single non-subcontract is created in the tx
exports.getTokenIdFromUnsignedTx = exports.getContractIdFromUnsignedTx;
function tryGetCallResult(result) {
    if (result.type === 'CallContractFailed') {
        throw new Error(`Failed to call contract, error: ${result.error}`);
    }
    return result;
}
exports.tryGetCallResult = tryGetCallResult;
